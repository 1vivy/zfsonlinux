From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Brian Behlendorf <behlendorf1@llnl.gov>
Date: Wed, 7 Feb 2018 11:50:24 -0800
Subject: [PATCH] Split spl-build.m4
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Split the kernel interface configure checks in to seperate m4
macro files.  This is intended to facilitate moving the spl
source code in to the zfs repository.

Reviewed-by: Tony Hutter <hutter2@llnl.gov>
Signed-off-by: Brian Behlendorf <behlendorf1@llnl.gov>
Closes #682
(cherry picked from commit 6902e2839f7efe32dab97980aa4b4c151bdb4f5e)
Signed-off-by: Fabian Gr√ºnbichler <f.gruenbichler@proxmox.com>
---
 config/kernel-ctl-table-name.m4      |  18 +
 config/kernel-fallocate.m4           |  68 +++
 config/kernel-group-info.m4          |  21 +
 config/kernel-inode-lock.m4          |  23 +
 config/kernel-kmem-cache.m4          |  72 +++
 config/kernel-kuidgid.m4             |  28 +
 config/kernel-pde-data.m4            |  17 +
 config/kernel-rw.m4                  |  57 +++
 config/kernel-rwsem.m4               |  75 +++
 config/kernel-sched.m4               |  56 ++
 config/kernel-set-fs-pwd.m4          |  39 ++
 config/kernel-shrinker.m4            | 125 +++++
 config/kernel-spinlock.m4            |  24 +
 config/kernel-timer.m4               |  32 ++
 config/kernel-trim-unused-symbols.m4 |  19 +
 config/kernel-truncate-range.m4      |  19 +
 config/kernel-urange-sleep.m4        |  21 +
 config/kernel-vfs-fsync.m4           |  17 +
 config/kernel-vfs-getattr.m4         |  62 +++
 config/kernel-wait.m4                |  76 +++
 config/kernel-zlib.m4                |  63 +++
 config/spl-build.m4                  | 956 -----------------------------------
 22 files changed, 932 insertions(+), 956 deletions(-)
 create mode 100644 config/kernel-ctl-table-name.m4
 create mode 100644 config/kernel-fallocate.m4
 create mode 100644 config/kernel-group-info.m4
 create mode 100644 config/kernel-inode-lock.m4
 create mode 100644 config/kernel-kmem-cache.m4
 create mode 100644 config/kernel-kuidgid.m4
 create mode 100644 config/kernel-pde-data.m4
 create mode 100644 config/kernel-rw.m4
 create mode 100644 config/kernel-rwsem.m4
 create mode 100644 config/kernel-sched.m4
 create mode 100644 config/kernel-set-fs-pwd.m4
 create mode 100644 config/kernel-shrinker.m4
 create mode 100644 config/kernel-spinlock.m4
 create mode 100644 config/kernel-timer.m4
 create mode 100644 config/kernel-trim-unused-symbols.m4
 create mode 100644 config/kernel-truncate-range.m4
 create mode 100644 config/kernel-urange-sleep.m4
 create mode 100644 config/kernel-vfs-fsync.m4
 create mode 100644 config/kernel-vfs-getattr.m4
 create mode 100644 config/kernel-wait.m4
 create mode 100644 config/kernel-zlib.m4

diff --git a/config/kernel-ctl-table-name.m4 b/config/kernel-ctl-table-name.m4
new file mode 100644
index 0000000..8dd2e77
--- /dev/null
+++ b/config/kernel-ctl-table-name.m4
@@ -0,0 +1,18 @@
+dnl #
+dnl # 2.6.33 API change,
+dnl # Removed .ctl_name from struct ctl_table.
+dnl #
+AC_DEFUN([SPL_AC_CTL_NAME], [
+	AC_MSG_CHECKING([whether struct ctl_table has ctl_name])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/sysctl.h>
+	],[
+		struct ctl_table ctl __attribute__ ((unused));
+		ctl.ctl_name = 0;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_CTL_NAME, 1, [struct ctl_table has ctl_name])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-fallocate.m4 b/config/kernel-fallocate.m4
new file mode 100644
index 0000000..b8c82f4
--- /dev/null
+++ b/config/kernel-fallocate.m4
@@ -0,0 +1,68 @@
+dnl #
+dnl # Linux 2.6.38 - 3.x API
+dnl #
+AC_DEFUN([SPL_AC_KERNEL_FILE_FALLOCATE], [
+	AC_MSG_CHECKING([whether fops->fallocate() exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		long (*fallocate) (struct file *, int, loff_t, loff_t) = NULL;
+		struct file_operations fops __attribute__ ((unused)) = {
+			.fallocate = fallocate,
+		};
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_FILE_FALLOCATE, 1, [fops->fallocate() exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+dnl #
+dnl # Linux 2.6.x - 2.6.37 API
+dnl #
+AC_DEFUN([SPL_AC_KERNEL_INODE_FALLOCATE], [
+	AC_MSG_CHECKING([whether iops->fallocate() exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		long (*fallocate) (struct inode *, int, loff_t, loff_t) = NULL;
+		struct inode_operations fops __attribute__ ((unused)) = {
+			.fallocate = fallocate,
+		};
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_INODE_FALLOCATE, 1, [fops->fallocate() exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # PaX Linux 2.6.38 - 3.x API
+dnl #
+AC_DEFUN([SPL_AC_PAX_KERNEL_FILE_FALLOCATE], [
+	AC_MSG_CHECKING([whether fops->fallocate() exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		long (*fallocate) (struct file *, int, loff_t, loff_t) = NULL;
+		struct file_operations_no_const fops __attribute__ ((unused)) = {
+			.fallocate = fallocate,
+		};
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_FILE_FALLOCATE, 1, [fops->fallocate() exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # The fallocate callback was moved from the inode_operations
+dnl # structure to the file_operations structure.
+dnl #
+AC_DEFUN([SPL_AC_KERNEL_FALLOCATE], [
+	SPL_AC_KERNEL_FILE_FALLOCATE
+	SPL_AC_KERNEL_INODE_FALLOCATE
+	SPL_AC_PAX_KERNEL_FILE_FALLOCATE
+])
diff --git a/config/kernel-group-info.m4 b/config/kernel-group-info.m4
new file mode 100644
index 0000000..4db2bba
--- /dev/null
+++ b/config/kernel-group-info.m4
@@ -0,0 +1,21 @@
+dnl #
+dnl # 4.9 API change
+dnl # group_info changed from 2d array via >blocks to 1d array via ->gid
+dnl #
+AC_DEFUN([SPL_AC_GROUP_INFO_GID], [
+	AC_MSG_CHECKING([whether group_info->gid exists])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/cred.h>
+	],[
+		struct group_info *gi = groups_alloc(1);
+		gi->gid[0] = KGIDT_INIT(0);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_GROUP_INFO_GID, 1, [group_info->gid exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-inode-lock.m4 b/config/kernel-inode-lock.m4
new file mode 100644
index 0000000..2cc06a5
--- /dev/null
+++ b/config/kernel-inode-lock.m4
@@ -0,0 +1,23 @@
+dnl #
+dnl # 4.7 API change
+dnl # i_mutex is changed to i_rwsem. Instead of directly using
+dnl # i_mutex/i_rwsem, we should use inode_lock() and inode_lock_shared()
+dnl # We test inode_lock_shared because inode_lock is introduced earlier.
+dnl #
+AC_DEFUN([SPL_AC_INODE_LOCK], [
+	AC_MSG_CHECKING([whether inode_lock_shared() exists])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		struct inode *inode = NULL;
+		inode_lock_shared(inode);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_INODE_LOCK_SHARED, 1, [yes])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-kmem-cache.m4 b/config/kernel-kmem-cache.m4
new file mode 100644
index 0000000..50a7fdb
--- /dev/null
+++ b/config/kernel-kmem-cache.m4
@@ -0,0 +1,72 @@
+dnl #
+dnl # 2.6.35 API change,
+dnl # The cachep->gfpflags member was renamed cachep->allocflags.  These are
+dnl # private allocation flags which are applied when allocating a new slab
+dnl # in kmem_getpages().  Unfortunately there is no public API for setting
+dnl # non-default flags.
+dnl #
+AC_DEFUN([SPL_AC_KMEM_CACHE_ALLOCFLAGS], [
+	AC_MSG_CHECKING([whether struct kmem_cache has allocflags])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/slab.h>
+	],[
+		struct kmem_cache cachep __attribute__ ((unused));
+		cachep.allocflags = GFP_KERNEL;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KMEM_CACHE_ALLOCFLAGS, 1,
+			[struct kmem_cache has allocflags])
+	],[
+		AC_MSG_RESULT(no)
+
+		AC_MSG_CHECKING([whether struct kmem_cache has gfpflags])
+		SPL_LINUX_TRY_COMPILE([
+			#include <linux/slab.h>
+		],[
+			struct kmem_cache cachep __attribute__ ((unused));
+			cachep.gfpflags = GFP_KERNEL;
+		],[
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_KMEM_CACHE_GFPFLAGS, 1,
+				[struct kmem_cache has gfpflags])
+		],[
+			AC_MSG_RESULT(no)
+		])
+	])
+])
+
+dnl #
+dnl # grsecurity API change,
+dnl # kmem_cache_create() with SLAB_USERCOPY flag replaced by
+dnl # kmem_cache_create_usercopy().
+dnl #
+AC_DEFUN([SPL_AC_KMEM_CACHE_CREATE_USERCOPY], [
+	AC_MSG_CHECKING([whether kmem_cache_create_usercopy() exists])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/slab.h>
+		static void ctor(void *foo)
+		{
+			// fake ctor
+		}
+	],[
+		struct kmem_cache *skc_linux_cache;
+		const char *name = "test";
+		size_t size = 4096;
+		size_t align = 8;
+		unsigned long flags = 0;
+		size_t useroffset = 0;
+		size_t usersize = size - useroffset;
+
+		skc_linux_cache = kmem_cache_create_usercopy(
+			name, size, align, flags, useroffset, usersize, ctor);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KMEM_CACHE_CREATE_USERCOPY, 1,
+				[kmem_cache_create_usercopy() exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-kuidgid.m4 b/config/kernel-kuidgid.m4
new file mode 100644
index 0000000..47d1937
--- /dev/null
+++ b/config/kernel-kuidgid.m4
@@ -0,0 +1,28 @@
+dnl #
+dnl # User namespaces, use kuid_t in place of uid_t
+dnl # where available. Not strictly a user namespaces thing
+dnl # but it should prevent surprises
+dnl #
+AC_DEFUN([SPL_AC_KUIDGID_T], [
+	AC_MSG_CHECKING([whether kuid_t/kgid_t is available])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/uidgid.h>
+	], [
+		kuid_t userid = KUIDT_INIT(0);
+		kgid_t groupid = KGIDT_INIT(0);
+	],[
+		SPL_LINUX_TRY_COMPILE([
+			#include <linux/uidgid.h>
+		], [
+			kuid_t userid = 0;
+			kgid_t groupid = 0;
+		],[
+			AC_MSG_RESULT(yes; optional)
+		],[
+			AC_MSG_RESULT(yes; mandatory)
+			AC_DEFINE(HAVE_KUIDGID_T, 1, [kuid_t/kgid_t in use])
+		])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-pde-data.m4 b/config/kernel-pde-data.m4
new file mode 100644
index 0000000..6aa5765
--- /dev/null
+++ b/config/kernel-pde-data.m4
@@ -0,0 +1,17 @@
+dnl #
+dnl # 3.10 API change,
+dnl # PDE is replaced by PDE_DATA
+dnl #
+AC_DEFUN([SPL_AC_PDE_DATA], [
+	AC_MSG_CHECKING([whether PDE_DATA() is available])
+	SPL_LINUX_TRY_COMPILE_SYMBOL([
+		#include <linux/proc_fs.h>
+	], [
+		PDE_DATA(NULL);
+	], [PDE_DATA], [], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_PDE_DATA, 1, [yes])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-rw.m4 b/config/kernel-rw.m4
new file mode 100644
index 0000000..23c14b7
--- /dev/null
+++ b/config/kernel-rw.m4
@@ -0,0 +1,57 @@
+dnl #
+dnl # 4.14 API change
+dnl # kernel_write() which was introduced in 3.9 was updated to take
+dnl # the offset as a pointer which is needed by vn_rdwr().
+dnl #
+AC_DEFUN([SPL_AC_KERNEL_WRITE], [
+	AC_MSG_CHECKING([whether kernel_write() takes loff_t pointer])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		struct file *file = NULL;
+		const void *buf = NULL;
+		size_t count = 0;
+		loff_t *pos = NULL;
+		ssize_t ret;
+
+		ret = kernel_write(file, buf, count, pos);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KERNEL_WRITE_PPOS, 1,
+		    [kernel_write() take loff_t pointer])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+dnl #
+dnl # 4.14 API change
+dnl # kernel_read() which has existed for forever was updated to take
+dnl # the offset as a pointer which is needed by vn_rdwr().
+dnl #
+AC_DEFUN([SPL_AC_KERNEL_READ], [
+	AC_MSG_CHECKING([whether kernel_read() takes loff_t pointer])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		struct file *file = NULL;
+		void *buf = NULL;
+		size_t count = 0;
+		loff_t *pos = NULL;
+		ssize_t ret;
+
+		ret = kernel_read(file, buf, count, pos);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KERNEL_READ_PPOS, 1,
+		    [kernel_read() take loff_t pointer])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-rwsem.m4 b/config/kernel-rwsem.m4
new file mode 100644
index 0000000..aee20ae
--- /dev/null
+++ b/config/kernel-rwsem.m4
@@ -0,0 +1,75 @@
+dnl #
+dnl # 3.1 API Change
+dnl #
+dnl # The rw_semaphore.wait_lock member was changed from spinlock_t to
+dnl # raw_spinlock_t at commit ddb6c9b58a19edcfac93ac670b066c836ff729f1.
+dnl #
+AC_DEFUN([SPL_AC_RWSEM_SPINLOCK_IS_RAW], [
+	AC_MSG_CHECKING([whether struct rw_semaphore member wait_lock is raw])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/rwsem.h>
+	],[
+		struct rw_semaphore dummy_semaphore __attribute__ ((unused));
+		raw_spinlock_t dummy_lock __attribute__ ((unused)) =
+		    __RAW_SPIN_LOCK_INITIALIZER(dummy_lock);
+		dummy_semaphore.wait_lock = dummy_lock;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(RWSEM_SPINLOCK_IS_RAW, 1,
+		[struct rw_semaphore member wait_lock is raw_spinlock_t])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+dnl #
+dnl # 3.16 API Change
+dnl #
+dnl # rwsem-spinlock "->activity" changed to "->count"
+dnl #
+AC_DEFUN([SPL_AC_RWSEM_ACTIVITY], [
+	AC_MSG_CHECKING([whether struct rw_semaphore has member activity])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/rwsem.h>
+	],[
+		struct rw_semaphore dummy_semaphore __attribute__ ((unused));
+		dummy_semaphore.activity = 0;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_RWSEM_ACTIVITY, 1,
+		[struct rw_semaphore has member activity])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+dnl #
+dnl # 4.8 API Change
+dnl #
+dnl # rwsem "->count" changed to atomic_long_t type
+dnl #
+AC_DEFUN([SPL_AC_RWSEM_ATOMIC_LONG_COUNT], [
+	AC_MSG_CHECKING(
+	[whether struct rw_semaphore has atomic_long_t member count])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/rwsem.h>
+	],[
+		DECLARE_RWSEM(dummy_semaphore);
+		(void) atomic_long_read(&dummy_semaphore.count);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_RWSEM_ATOMIC_LONG_COUNT, 1,
+		[struct rw_semaphore has atomic_long_t member count])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-sched.m4 b/config/kernel-sched.m4
new file mode 100644
index 0000000..5ae2167
--- /dev/null
+++ b/config/kernel-sched.m4
@@ -0,0 +1,56 @@
+dnl #
+dnl # 3.9 API change,
+dnl # Moved things from linux/sched.h to linux/sched/rt.h
+dnl #
+AC_DEFUN([SPL_AC_SCHED_RT_HEADER],
+	[AC_MSG_CHECKING([whether header linux/sched/rt.h exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/sched.h>
+		#include <linux/sched/rt.h>
+	],[
+		return 0;
+	],[
+		AC_DEFINE(HAVE_SCHED_RT_HEADER, 1, [linux/sched/rt.h exists])
+		AC_MSG_RESULT(yes)
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 4.11 API change,
+dnl # Moved things from linux/sched.h to linux/sched/signal.h
+dnl #
+AC_DEFUN([SPL_AC_SCHED_SIGNAL_HEADER],
+	[AC_MSG_CHECKING([whether header linux/sched/signal.h exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/sched.h>
+		#include <linux/sched/signal.h>
+	],[
+		return 0;
+	],[
+		AC_DEFINE(HAVE_SCHED_SIGNAL_HEADER, 1, [linux/sched/signal.h exists])
+		AC_MSG_RESULT(yes)
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+dnl #
+dnl # 3.19 API change
+dnl # The io_schedule_timeout() function is present in all 2.6.32 kernels
+dnl # but it was not exported until Linux 3.19.  The RHEL 7.x kernels which
+dnl # are based on a 3.10 kernel do export this symbol.
+dnl #
+AC_DEFUN([SPL_AC_IO_SCHEDULE_TIMEOUT], [
+	AC_MSG_CHECKING([whether io_schedule_timeout() is available])
+	SPL_LINUX_TRY_COMPILE_SYMBOL([
+		#include <linux/sched.h>
+	], [
+		(void) io_schedule_timeout(1);
+	], [io_schedule_timeout], [], [
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_IO_SCHEDULE_TIMEOUT, 1, [yes])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-set-fs-pwd.m4 b/config/kernel-set-fs-pwd.m4
new file mode 100644
index 0000000..849e7e6
--- /dev/null
+++ b/config/kernel-set-fs-pwd.m4
@@ -0,0 +1,39 @@
+dnl #
+dnl # 3.9 API change
+dnl # set_fs_pwd takes const struct path *
+dnl #
+AC_DEFUN([SPL_AC_SET_FS_PWD_WITH_CONST],
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	[AC_MSG_CHECKING([whether set_fs_pwd() requires const struct path *])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/spinlock.h>
+		#include <linux/fs_struct.h>
+		#include <linux/path.h>
+		void (*const set_fs_pwd_func)
+			(struct fs_struct *, const struct path *)
+			= set_fs_pwd;
+	],[
+		return 0;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_SET_FS_PWD_WITH_CONST, 1,
+			[set_fs_pwd() needs const path *])
+	],[
+		SPL_LINUX_TRY_COMPILE([
+			#include <linux/spinlock.h>
+			#include <linux/fs_struct.h>
+			#include <linux/path.h>
+			void (*const set_fs_pwd_func)
+				(struct fs_struct *, struct path *)
+				= set_fs_pwd;
+		],[
+			return 0;
+		],[
+			AC_MSG_RESULT(no)
+		],[
+			AC_MSG_ERROR(unknown)
+		])
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-shrinker.m4 b/config/kernel-shrinker.m4
new file mode 100644
index 0000000..6fc9b54
--- /dev/null
+++ b/config/kernel-shrinker.m4
@@ -0,0 +1,125 @@
+AC_DEFUN([SPL_AC_SHRINKER_CALLBACK],[
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	dnl #
+	dnl # 2.6.23 to 2.6.34 API change
+	dnl # ->shrink(int nr_to_scan, gfp_t gfp_mask)
+	dnl #
+	AC_MSG_CHECKING([whether old 2-argument shrinker exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/mm.h>
+
+		int shrinker_cb(int nr_to_scan, gfp_t gfp_mask);
+	],[
+		struct shrinker cache_shrinker = {
+			.shrink = shrinker_cb,
+			.seeks = DEFAULT_SEEKS,
+		};
+		register_shrinker(&cache_shrinker);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_2ARGS_OLD_SHRINKER_CALLBACK, 1,
+			[old shrinker callback wants 2 args])
+	],[
+		AC_MSG_RESULT(no)
+		dnl #
+		dnl # 2.6.35 - 2.6.39 API change
+		dnl # ->shrink(struct shrinker *,
+		dnl #          int nr_to_scan, gfp_t gfp_mask)
+		dnl #
+		AC_MSG_CHECKING([whether old 3-argument shrinker exists])
+		SPL_LINUX_TRY_COMPILE([
+			#include <linux/mm.h>
+
+			int shrinker_cb(struct shrinker *, int nr_to_scan,
+					gfp_t gfp_mask);
+		],[
+			struct shrinker cache_shrinker = {
+				.shrink = shrinker_cb,
+				.seeks = DEFAULT_SEEKS,
+			};
+			register_shrinker(&cache_shrinker);
+		],[
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_3ARGS_SHRINKER_CALLBACK, 1,
+				[old shrinker callback wants 3 args])
+		],[
+			AC_MSG_RESULT(no)
+			dnl #
+			dnl # 3.0 - 3.11 API change
+			dnl # ->shrink(struct shrinker *,
+			dnl #          struct shrink_control *sc)
+			dnl #
+			AC_MSG_CHECKING(
+				[whether new 2-argument shrinker exists])
+			SPL_LINUX_TRY_COMPILE([
+				#include <linux/mm.h>
+
+				int shrinker_cb(struct shrinker *,
+						struct shrink_control *sc);
+			],[
+				struct shrinker cache_shrinker = {
+					.shrink = shrinker_cb,
+					.seeks = DEFAULT_SEEKS,
+				};
+				register_shrinker(&cache_shrinker);
+			],[
+				AC_MSG_RESULT(yes)
+				AC_DEFINE(HAVE_2ARGS_NEW_SHRINKER_CALLBACK, 1,
+					[new shrinker callback wants 2 args])
+			],[
+				AC_MSG_RESULT(no)
+				dnl #
+				dnl # 3.12 API change,
+				dnl # ->shrink() is logically split in to
+				dnl # ->count_objects() and ->scan_objects()
+				dnl #
+				AC_MSG_CHECKING(
+				    [whether ->count_objects callback exists])
+				SPL_LINUX_TRY_COMPILE([
+					#include <linux/mm.h>
+
+					unsigned long shrinker_cb(
+						struct shrinker *,
+						struct shrink_control *sc);
+				],[
+					struct shrinker cache_shrinker = {
+						.count_objects = shrinker_cb,
+						.scan_objects = shrinker_cb,
+						.seeks = DEFAULT_SEEKS,
+					};
+					register_shrinker(&cache_shrinker);
+				],[
+					AC_MSG_RESULT(yes)
+					AC_DEFINE(HAVE_SPLIT_SHRINKER_CALLBACK,
+						1, [->count_objects exists])
+				],[
+					AC_MSG_ERROR(error)
+				])
+			])
+		])
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
+
+dnl #
+dnl # 2.6.39 API change,
+dnl # Shrinker adjust to use common shrink_control structure.
+dnl #
+AC_DEFUN([SPL_AC_SHRINK_CONTROL_STRUCT], [
+	AC_MSG_CHECKING([whether struct shrink_control exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/mm.h>
+	],[
+		struct shrink_control sc __attribute__ ((unused));
+
+		sc.nr_to_scan = 0;
+		sc.gfp_mask = GFP_KERNEL;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_SHRINK_CONTROL_STRUCT, 1,
+			[struct shrink_control exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-spinlock.m4 b/config/kernel-spinlock.m4
new file mode 100644
index 0000000..136262d
--- /dev/null
+++ b/config/kernel-spinlock.m4
@@ -0,0 +1,24 @@
+dnl #
+dnl # 2.6.36 API change,
+dnl # The 'struct fs_struct->lock' was changed from a rwlock_t to
+dnl # a spinlock_t to improve the fastpath performance.
+dnl #
+AC_DEFUN([SPL_AC_FS_STRUCT_SPINLOCK], [
+	AC_MSG_CHECKING([whether struct fs_struct uses spinlock_t])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/sched.h>
+		#include <linux/fs_struct.h>
+	],[
+		static struct fs_struct fs;
+		spin_lock_init(&fs.lock);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_FS_STRUCT_SPINLOCK, 1,
+		          [struct fs_struct uses spinlock_t])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-timer.m4 b/config/kernel-timer.m4
new file mode 100644
index 0000000..93b5158
--- /dev/null
+++ b/config/kernel-timer.m4
@@ -0,0 +1,32 @@
+dnl #
+dnl # 4.15 API change
+dnl # https://lkml.org/lkml/2017/11/25/90
+dnl # Check if timer_list.func get passed a timer_list or an unsigned long
+dnl # (older kernels).  Also sanity check the from_timer() and timer_setup()
+dnl # macros are available as well, since they will be used in the same newer
+dnl # kernels that support the new timer_list.func signature.
+dnl #
+AC_DEFUN([SPL_AC_KERNEL_TIMER_FUNCTION_TIMER_LIST], [
+	AC_MSG_CHECKING([whether timer_list.function gets a timer_list])
+	tmp_flags="$EXTRA_KCFLAGS"
+	EXTRA_KCFLAGS="-Werror"
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/timer.h>
+		void task_expire(struct timer_list *tl) {}
+	],[
+		#ifndef from_timer
+		#error "No from_timer() macro"
+		#endif
+
+		struct timer_list timer;
+		timer.function = task_expire;
+		timer_setup(&timer, NULL, 0);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_KERNEL_TIMER_FUNCTION_TIMER_LIST, 1,
+		    [timer_list.function gets a timer_list])
+	],[
+		AC_MSG_RESULT(no)
+	])
+	EXTRA_KCFLAGS="$tmp_flags"
+])
diff --git a/config/kernel-trim-unused-symbols.m4 b/config/kernel-trim-unused-symbols.m4
new file mode 100644
index 0000000..d1ac2f3
--- /dev/null
+++ b/config/kernel-trim-unused-symbols.m4
@@ -0,0 +1,19 @@
+dnl #
+dnl # config trim unused symbols,
+dnl # Verify the kernel has CONFIG_TRIM_UNUSED_KSYMS DISABLED.
+dnl #
+AC_DEFUN([SPL_AC_CONFIG_TRIM_UNUSED_KSYMS], [
+	AC_MSG_CHECKING([whether CONFIG_TRIM_UNUSED_KSYM is disabled])
+	SPL_LINUX_TRY_COMPILE([
+		#if defined(CONFIG_TRIM_UNUSED_KSYMS)
+		#error CONFIG_TRIM_UNUSED_KSYMS not defined
+		#endif
+	],[ ],[
+		AC_MSG_RESULT([yes])
+	],[
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR([
+	*** This kernel has unused symbols trimming enabled, please disable.
+	*** Rebuild the kernel with CONFIG_TRIM_UNUSED_KSYMS=n set.])
+	])
+])
diff --git a/config/kernel-truncate-range.m4 b/config/kernel-truncate-range.m4
new file mode 100644
index 0000000..4b1600b
--- /dev/null
+++ b/config/kernel-truncate-range.m4
@@ -0,0 +1,19 @@
+dnl #
+dnl # 3.5 API change,
+dnl # inode_operations.truncate_range removed
+dnl #
+AC_DEFUN([SPL_AC_INODE_TRUNCATE_RANGE], [
+	AC_MSG_CHECKING([whether truncate_range() inode operation is available])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		struct inode_operations ops;
+		ops.truncate_range = NULL;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_INODE_TRUNCATE_RANGE, 1,
+			[truncate_range() inode operation is available])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-urange-sleep.m4 b/config/kernel-urange-sleep.m4
new file mode 100644
index 0000000..85beca6
--- /dev/null
+++ b/config/kernel-urange-sleep.m4
@@ -0,0 +1,21 @@
+dnl #
+dnl # 2.6.36 API compatibility.
+dnl # Added usleep_range timer.
+dnl # usleep_range is a finer precision implementation of msleep
+dnl # designed to be a drop-in replacement for udelay where a precise
+dnl # sleep / busy-wait is unnecessary.
+dnl #
+AC_DEFUN([SPL_AC_USLEEP_RANGE], [
+	AC_MSG_CHECKING([whether usleep_range() is available])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/delay.h>
+	],[
+		usleep_range(0, 0);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_USLEEP_RANGE, 1,
+		          [usleep_range is available])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-vfs-fsync.m4 b/config/kernel-vfs-fsync.m4
new file mode 100644
index 0000000..3c42bf1
--- /dev/null
+++ b/config/kernel-vfs-fsync.m4
@@ -0,0 +1,17 @@
+dnl #
+dnl # 2.6.35 API change,
+dnl # Unused 'struct dentry *' removed from vfs_fsync() prototype.
+dnl #
+AC_DEFUN([SPL_AC_2ARGS_VFS_FSYNC], [
+	AC_MSG_CHECKING([whether vfs_fsync() wants 2 args])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		vfs_fsync(NULL, 0);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_2ARGS_VFS_FSYNC, 1, [vfs_fsync() wants 2 args])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-vfs-getattr.m4 b/config/kernel-vfs-getattr.m4
new file mode 100644
index 0000000..7772cb5
--- /dev/null
+++ b/config/kernel-vfs-getattr.m4
@@ -0,0 +1,62 @@
+dnl #
+dnl # 4.11 API, a528d35e@torvalds/linux
+dnl # vfs_getattr(const struct path *p, struct kstat *s, u32 m, unsigned int f)
+dnl #
+AC_DEFUN([SPL_AC_4ARGS_VFS_GETATTR], [
+	AC_MSG_CHECKING([whether vfs_getattr() wants 4 args])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		vfs_getattr((const struct path *)NULL,
+			(struct kstat *)NULL,
+			(u32)0,
+			(unsigned int)0);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_4ARGS_VFS_GETATTR, 1,
+		  [vfs_getattr wants 4 args])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 3.9 API
+dnl # vfs_getattr(struct path *p, struct kstat *s)
+dnl #
+AC_DEFUN([SPL_AC_2ARGS_VFS_GETATTR], [
+	AC_MSG_CHECKING([whether vfs_getattr() wants 2 args])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		vfs_getattr((struct path *) NULL,
+			(struct kstat *)NULL);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_2ARGS_VFS_GETATTR, 1,
+			  [vfs_getattr wants 2 args])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # <3.9 API
+dnl # vfs_getattr(struct vfsmount *v, struct dentry *d, struct kstat *k)
+dnl #
+AC_DEFUN([SPL_AC_3ARGS_VFS_GETATTR], [
+	AC_MSG_CHECKING([whether vfs_getattr() wants 3 args])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+	],[
+		vfs_getattr((struct vfsmount *)NULL,
+			(struct dentry *)NULL,
+			(struct kstat *)NULL);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_3ARGS_VFS_GETATTR, 1,
+		  [vfs_getattr wants 3 args])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-wait.m4 b/config/kernel-wait.m4
new file mode 100644
index 0000000..5f718a1
--- /dev/null
+++ b/config/kernel-wait.m4
@@ -0,0 +1,76 @@
+dnl #
+dnl # 3.17 API change,
+dnl # wait_on_bit() no longer requires an action argument. The former
+dnl # "wait_on_bit" interface required an 'action' function to be provided
+dnl # which does the actual waiting. There were over 20 such functions in the
+dnl # kernel, many of them identical, though most cases can be satisfied by one
+dnl # of just two functions: one which uses io_schedule() and one which just
+dnl # uses schedule().  This API change was made to consolidate all of those
+dnl # redundant wait functions.
+dnl #
+AC_DEFUN([SPL_AC_WAIT_ON_BIT], [
+	AC_MSG_CHECKING([whether wait_on_bit() takes an action])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/wait.h>
+	],[
+		int (*action)(void *) = NULL;
+		wait_on_bit(NULL, 0, action, 0);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_WAIT_ON_BIT_ACTION, 1, [yes])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+dnl #
+dnl # 4.13 API change
+dnl # Renamed struct wait_queue -> struct wait_queue_entry.
+dnl #
+AC_DEFUN([SPL_AC_WAIT_QUEUE_ENTRY_T], [
+	AC_MSG_CHECKING([whether wait_queue_entry_t exists])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/wait.h>
+	],[
+		wait_queue_entry_t *entry __attribute__ ((unused));
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_WAIT_QUEUE_ENTRY_T, 1,
+		    [wait_queue_entry_t exists])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
+
+dnl #
+dnl # 4.13 API change
+dnl # Renamed wait_queue_head::task_list -> wait_queue_head::head
+dnl # Renamed wait_queue_entry::task_list -> wait_queue_entry::entry
+dnl #
+AC_DEFUN([SPL_AC_WAIT_QUEUE_HEAD_ENTRY], [
+	AC_MSG_CHECKING([whether wq_head->head and wq_entry->entry exist])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/wait.h>
+
+		#ifdef HAVE_WAIT_QUEUE_ENTRY_T
+		typedef wait_queue_head_t	spl_wait_queue_head_t;
+		typedef wait_queue_entry_t	spl_wait_queue_entry_t;
+		#else
+		typedef wait_queue_head_t	spl_wait_queue_head_t;
+		typedef wait_queue_t		spl_wait_queue_entry_t;
+		#endif
+	],[
+		spl_wait_queue_head_t wq_head;
+		spl_wait_queue_entry_t wq_entry;
+		struct list_head *head __attribute__ ((unused));
+		struct list_head *entry __attribute__ ((unused));
+
+		head = &wq_head.head;
+		entry = &wq_entry.entry;
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_WAIT_QUEUE_HEAD_ENTRY, 1,
+		    [wq_head->head and wq_entry->entry exist])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/kernel-zlib.m4 b/config/kernel-zlib.m4
new file mode 100644
index 0000000..bb23646
--- /dev/null
+++ b/config/kernel-zlib.m4
@@ -0,0 +1,63 @@
+dnl #
+dnl # zlib inflate compat,
+dnl # Verify the kernel has CONFIG_ZLIB_INFLATE support enabled.
+dnl #
+AC_DEFUN([SPL_AC_CONFIG_ZLIB_INFLATE], [
+	AC_MSG_CHECKING([whether CONFIG_ZLIB_INFLATE is defined])
+	SPL_LINUX_TRY_COMPILE([
+		#if !defined(CONFIG_ZLIB_INFLATE) && \
+		    !defined(CONFIG_ZLIB_INFLATE_MODULE)
+		#error CONFIG_ZLIB_INFLATE not defined
+		#endif
+	],[ ],[
+		AC_MSG_RESULT([yes])
+	],[
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR([
+	*** This kernel does not include the required zlib inflate support.
+	*** Rebuild the kernel with CONFIG_ZLIB_INFLATE=y|m set.])
+	])
+])
+
+dnl #
+dnl # zlib deflate compat,
+dnl # Verify the kernel has CONFIG_ZLIB_DEFLATE support enabled.
+dnl #
+AC_DEFUN([SPL_AC_CONFIG_ZLIB_DEFLATE], [
+	AC_MSG_CHECKING([whether CONFIG_ZLIB_DEFLATE is defined])
+	SPL_LINUX_TRY_COMPILE([
+		#if !defined(CONFIG_ZLIB_DEFLATE) && \
+		    !defined(CONFIG_ZLIB_DEFLATE_MODULE)
+		#error CONFIG_ZLIB_DEFLATE not defined
+		#endif
+	],[ ],[
+		AC_MSG_RESULT([yes])
+	],[
+		AC_MSG_RESULT([no])
+		AC_MSG_ERROR([
+	*** This kernel does not include the required zlib deflate support.
+	*** Rebuild the kernel with CONFIG_ZLIB_DEFLATE=y|m set.])
+	])
+])
+
+dnl #
+dnl # 2.6.39 API compat,
+dnl # The function zlib_deflate_workspacesize() now take 2 arguments.
+dnl # This was done to avoid always having to allocate the maximum size
+dnl # workspace (268K).  The caller can now specific the windowBits and
+dnl # memLevel compression parameters to get a smaller workspace.
+dnl #
+AC_DEFUN([SPL_AC_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE],
+	[AC_MSG_CHECKING([whether zlib_deflate_workspacesize() wants 2 args])
+	SPL_LINUX_TRY_COMPILE([
+		#include <linux/zlib.h>
+	],[
+		return zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL);
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE, 1,
+		          [zlib_deflate_workspacesize() wants 2 args])
+	],[
+		AC_MSG_RESULT(no)
+	])
+])
diff --git a/config/spl-build.m4 b/config/spl-build.m4
index afc8de6..553b5d5 100644
--- a/config/spl-build.m4
+++ b/config/spl-build.m4
@@ -753,959 +753,3 @@ AC_DEFUN([SPL_AC_ATOMIC_SPINLOCK], [
 	AC_MSG_CHECKING([whether kernel defines atomic64_t])
 	AC_MSG_RESULT([$have_atomic64_t])
 ])
-
-AC_DEFUN([SPL_AC_SHRINKER_CALLBACK],[
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	dnl #
-	dnl # 2.6.23 to 2.6.34 API change
-	dnl # ->shrink(int nr_to_scan, gfp_t gfp_mask)
-	dnl #
-	AC_MSG_CHECKING([whether old 2-argument shrinker exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/mm.h>
-
-		int shrinker_cb(int nr_to_scan, gfp_t gfp_mask);
-	],[
-		struct shrinker cache_shrinker = {
-			.shrink = shrinker_cb,
-			.seeks = DEFAULT_SEEKS,
-		};
-		register_shrinker(&cache_shrinker);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_2ARGS_OLD_SHRINKER_CALLBACK, 1,
-			[old shrinker callback wants 2 args])
-	],[
-		AC_MSG_RESULT(no)
-		dnl #
-		dnl # 2.6.35 - 2.6.39 API change
-		dnl # ->shrink(struct shrinker *,
-		dnl #          int nr_to_scan, gfp_t gfp_mask)
-		dnl #
-		AC_MSG_CHECKING([whether old 3-argument shrinker exists])
-		SPL_LINUX_TRY_COMPILE([
-			#include <linux/mm.h>
-
-			int shrinker_cb(struct shrinker *, int nr_to_scan,
-					gfp_t gfp_mask);
-		],[
-			struct shrinker cache_shrinker = {
-				.shrink = shrinker_cb,
-				.seeks = DEFAULT_SEEKS,
-			};
-			register_shrinker(&cache_shrinker);
-		],[
-			AC_MSG_RESULT(yes)
-			AC_DEFINE(HAVE_3ARGS_SHRINKER_CALLBACK, 1,
-				[old shrinker callback wants 3 args])
-		],[
-			AC_MSG_RESULT(no)
-			dnl #
-			dnl # 3.0 - 3.11 API change
-			dnl # ->shrink(struct shrinker *,
-			dnl #          struct shrink_control *sc)
-			dnl #
-			AC_MSG_CHECKING(
-				[whether new 2-argument shrinker exists])
-			SPL_LINUX_TRY_COMPILE([
-				#include <linux/mm.h>
-
-				int shrinker_cb(struct shrinker *,
-						struct shrink_control *sc);
-			],[
-				struct shrinker cache_shrinker = {
-					.shrink = shrinker_cb,
-					.seeks = DEFAULT_SEEKS,
-				};
-				register_shrinker(&cache_shrinker);
-			],[
-				AC_MSG_RESULT(yes)
-				AC_DEFINE(HAVE_2ARGS_NEW_SHRINKER_CALLBACK, 1,
-					[new shrinker callback wants 2 args])
-			],[
-				AC_MSG_RESULT(no)
-				dnl #
-				dnl # 3.12 API change,
-				dnl # ->shrink() is logically split in to
-				dnl # ->count_objects() and ->scan_objects()
-				dnl #
-				AC_MSG_CHECKING(
-				    [whether ->count_objects callback exists])
-				SPL_LINUX_TRY_COMPILE([
-					#include <linux/mm.h>
-
-					unsigned long shrinker_cb(
-						struct shrinker *,
-						struct shrink_control *sc);
-				],[
-					struct shrinker cache_shrinker = {
-						.count_objects = shrinker_cb,
-						.scan_objects = shrinker_cb,
-						.seeks = DEFAULT_SEEKS,
-					};
-					register_shrinker(&cache_shrinker);
-				],[
-					AC_MSG_RESULT(yes)
-					AC_DEFINE(HAVE_SPLIT_SHRINKER_CALLBACK,
-						1, [->count_objects exists])
-				],[
-					AC_MSG_ERROR(error)
-				])
-			])
-		])
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 2.6.33 API change,
-dnl # Removed .ctl_name from struct ctl_table.
-dnl #
-AC_DEFUN([SPL_AC_CTL_NAME], [
-	AC_MSG_CHECKING([whether struct ctl_table has ctl_name])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/sysctl.h>
-	],[
-		struct ctl_table ctl __attribute__ ((unused));
-		ctl.ctl_name = 0;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_CTL_NAME, 1, [struct ctl_table has ctl_name])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 3.10 API change,
-dnl # PDE is replaced by PDE_DATA
-dnl #
-AC_DEFUN([SPL_AC_PDE_DATA], [
-	AC_MSG_CHECKING([whether PDE_DATA() is available])
-	SPL_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/proc_fs.h>
-	], [
-		PDE_DATA(NULL);
-	], [PDE_DATA], [], [
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_PDE_DATA, 1, [yes])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 3.9 API change
-dnl # set_fs_pwd takes const struct path *
-dnl #
-AC_DEFUN([SPL_AC_SET_FS_PWD_WITH_CONST],
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	[AC_MSG_CHECKING([whether set_fs_pwd() requires const struct path *])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/spinlock.h>
-		#include <linux/fs_struct.h>
-		#include <linux/path.h>
-		void (*const set_fs_pwd_func)
-			(struct fs_struct *, const struct path *)
-			= set_fs_pwd;
-	],[
-		return 0;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_SET_FS_PWD_WITH_CONST, 1,
-			[set_fs_pwd() needs const path *])
-	],[
-		SPL_LINUX_TRY_COMPILE([
-			#include <linux/spinlock.h>
-			#include <linux/fs_struct.h>
-			#include <linux/path.h>
-			void (*const set_fs_pwd_func)
-				(struct fs_struct *, struct path *)
-				= set_fs_pwd;
-		],[
-			return 0;
-		],[
-			AC_MSG_RESULT(no)
-		],[
-			AC_MSG_ERROR(unknown)
-		])
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 2.6.36 API change,
-dnl # The 'struct fs_struct->lock' was changed from a rwlock_t to
-dnl # a spinlock_t to improve the fastpath performance.
-dnl #
-AC_DEFUN([SPL_AC_FS_STRUCT_SPINLOCK], [
-	AC_MSG_CHECKING([whether struct fs_struct uses spinlock_t])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/sched.h>
-		#include <linux/fs_struct.h>
-	],[
-		static struct fs_struct fs;
-		spin_lock_init(&fs.lock);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_FS_STRUCT_SPINLOCK, 1,
-		          [struct fs_struct uses spinlock_t])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # User namespaces, use kuid_t in place of uid_t
-dnl # where available. Not strictly a user namespaces thing
-dnl # but it should prevent surprises
-dnl #
-AC_DEFUN([SPL_AC_KUIDGID_T], [
-	AC_MSG_CHECKING([whether kuid_t/kgid_t is available])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/uidgid.h>
-	], [
-		kuid_t userid = KUIDT_INIT(0);
-		kgid_t groupid = KGIDT_INIT(0);
-	],[
-		SPL_LINUX_TRY_COMPILE([
-			#include <linux/uidgid.h>
-		], [
-			kuid_t userid = 0;
-			kgid_t groupid = 0;
-		],[
-			AC_MSG_RESULT(yes; optional)
-		],[
-			AC_MSG_RESULT(yes; mandatory)
-			AC_DEFINE(HAVE_KUIDGID_T, 1, [kuid_t/kgid_t in use])
-		])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 2.6.35 API change,
-dnl # Unused 'struct dentry *' removed from vfs_fsync() prototype.
-dnl #
-AC_DEFUN([SPL_AC_2ARGS_VFS_FSYNC], [
-	AC_MSG_CHECKING([whether vfs_fsync() wants 2 args])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		vfs_fsync(NULL, 0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_2ARGS_VFS_FSYNC, 1, [vfs_fsync() wants 2 args])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 3.5 API change,
-dnl # inode_operations.truncate_range removed
-dnl #
-AC_DEFUN([SPL_AC_INODE_TRUNCATE_RANGE], [
-	AC_MSG_CHECKING([whether truncate_range() inode operation is available])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		struct inode_operations ops;
-		ops.truncate_range = NULL;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_INODE_TRUNCATE_RANGE, 1,
-			[truncate_range() inode operation is available])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # Linux 2.6.38 - 3.x API
-dnl #
-AC_DEFUN([SPL_AC_KERNEL_FILE_FALLOCATE], [
-	AC_MSG_CHECKING([whether fops->fallocate() exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		long (*fallocate) (struct file *, int, loff_t, loff_t) = NULL;
-		struct file_operations fops __attribute__ ((unused)) = {
-			.fallocate = fallocate,
-		};
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_FILE_FALLOCATE, 1, [fops->fallocate() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # Linux 2.6.x - 2.6.37 API
-dnl #
-AC_DEFUN([SPL_AC_KERNEL_INODE_FALLOCATE], [
-	AC_MSG_CHECKING([whether iops->fallocate() exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		long (*fallocate) (struct inode *, int, loff_t, loff_t) = NULL;
-		struct inode_operations fops __attribute__ ((unused)) = {
-			.fallocate = fallocate,
-		};
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_INODE_FALLOCATE, 1, [fops->fallocate() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # PaX Linux 2.6.38 - 3.x API
-dnl #
-AC_DEFUN([SPL_AC_PAX_KERNEL_FILE_FALLOCATE], [
-	AC_MSG_CHECKING([whether fops->fallocate() exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		long (*fallocate) (struct file *, int, loff_t, loff_t) = NULL;
-		struct file_operations_no_const fops __attribute__ ((unused)) = {
-			.fallocate = fallocate,
-		};
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_FILE_FALLOCATE, 1, [fops->fallocate() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # The fallocate callback was moved from the inode_operations
-dnl # structure to the file_operations structure.
-dnl #
-AC_DEFUN([SPL_AC_KERNEL_FALLOCATE], [
-	SPL_AC_KERNEL_FILE_FALLOCATE
-	SPL_AC_KERNEL_INODE_FALLOCATE
-	SPL_AC_PAX_KERNEL_FILE_FALLOCATE
-])
-
-dnl #
-dnl # zlib inflate compat,
-dnl # Verify the kernel has CONFIG_ZLIB_INFLATE support enabled.
-dnl #
-AC_DEFUN([SPL_AC_CONFIG_ZLIB_INFLATE], [
-	AC_MSG_CHECKING([whether CONFIG_ZLIB_INFLATE is defined])
-	SPL_LINUX_TRY_COMPILE([
-		#if !defined(CONFIG_ZLIB_INFLATE) && \
-		    !defined(CONFIG_ZLIB_INFLATE_MODULE)
-		#error CONFIG_ZLIB_INFLATE not defined
-		#endif
-	],[ ],[
-		AC_MSG_RESULT([yes])
-	],[
-		AC_MSG_RESULT([no])
-		AC_MSG_ERROR([
-	*** This kernel does not include the required zlib inflate support.
-	*** Rebuild the kernel with CONFIG_ZLIB_INFLATE=y|m set.])
-	])
-])
-
-dnl #
-dnl # zlib deflate compat,
-dnl # Verify the kernel has CONFIG_ZLIB_DEFLATE support enabled.
-dnl #
-AC_DEFUN([SPL_AC_CONFIG_ZLIB_DEFLATE], [
-	AC_MSG_CHECKING([whether CONFIG_ZLIB_DEFLATE is defined])
-	SPL_LINUX_TRY_COMPILE([
-		#if !defined(CONFIG_ZLIB_DEFLATE) && \
-		    !defined(CONFIG_ZLIB_DEFLATE_MODULE)
-		#error CONFIG_ZLIB_DEFLATE not defined
-		#endif
-	],[ ],[
-		AC_MSG_RESULT([yes])
-	],[
-		AC_MSG_RESULT([no])
-		AC_MSG_ERROR([
-	*** This kernel does not include the required zlib deflate support.
-	*** Rebuild the kernel with CONFIG_ZLIB_DEFLATE=y|m set.])
-	])
-])
-
-dnl #
-dnl # config trim unused symbols,
-dnl # Verify the kernel has CONFIG_TRIM_UNUSED_KSYMS DISABLED.
-dnl #
-AC_DEFUN([SPL_AC_CONFIG_TRIM_UNUSED_KSYMS], [
-	AC_MSG_CHECKING([whether CONFIG_TRIM_UNUSED_KSYM is disabled])
-	SPL_LINUX_TRY_COMPILE([
-		#if defined(CONFIG_TRIM_UNUSED_KSYMS)
-		#error CONFIG_TRIM_UNUSED_KSYMS not defined
-		#endif
-	],[ ],[
-		AC_MSG_RESULT([yes])
-	],[
-		AC_MSG_RESULT([no])
-		AC_MSG_ERROR([
-	*** This kernel has unused symbols trimming enabled, please disable.
-	*** Rebuild the kernel with CONFIG_TRIM_UNUSED_KSYMS=n set.])
-	])
-])
-
-dnl #
-dnl # 2.6.39 API compat,
-dnl # The function zlib_deflate_workspacesize() now take 2 arguments.
-dnl # This was done to avoid always having to allocate the maximum size
-dnl # workspace (268K).  The caller can now specific the windowBits and
-dnl # memLevel compression parameters to get a smaller workspace.
-dnl #
-AC_DEFUN([SPL_AC_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE],
-	[AC_MSG_CHECKING([whether zlib_deflate_workspacesize() wants 2 args])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/zlib.h>
-	],[
-		return zlib_deflate_workspacesize(MAX_WBITS, MAX_MEM_LEVEL);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_2ARGS_ZLIB_DEFLATE_WORKSPACESIZE, 1,
-		          [zlib_deflate_workspacesize() wants 2 args])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 2.6.39 API change,
-dnl # Shrinker adjust to use common shrink_control structure.
-dnl #
-AC_DEFUN([SPL_AC_SHRINK_CONTROL_STRUCT], [
-	AC_MSG_CHECKING([whether struct shrink_control exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/mm.h>
-	],[
-		struct shrink_control sc __attribute__ ((unused));
-
-		sc.nr_to_scan = 0;
-		sc.gfp_mask = GFP_KERNEL;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_SHRINK_CONTROL_STRUCT, 1,
-			[struct shrink_control exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 3.1 API Change
-dnl #
-dnl # The rw_semaphore.wait_lock member was changed from spinlock_t to
-dnl # raw_spinlock_t at commit ddb6c9b58a19edcfac93ac670b066c836ff729f1.
-dnl #
-AC_DEFUN([SPL_AC_RWSEM_SPINLOCK_IS_RAW], [
-	AC_MSG_CHECKING([whether struct rw_semaphore member wait_lock is raw])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/rwsem.h>
-	],[
-		struct rw_semaphore dummy_semaphore __attribute__ ((unused));
-		raw_spinlock_t dummy_lock __attribute__ ((unused)) =
-		    __RAW_SPIN_LOCK_INITIALIZER(dummy_lock);
-		dummy_semaphore.wait_lock = dummy_lock;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(RWSEM_SPINLOCK_IS_RAW, 1,
-		[struct rw_semaphore member wait_lock is raw_spinlock_t])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 3.16 API Change
-dnl #
-dnl # rwsem-spinlock "->activity" changed to "->count"
-dnl #
-AC_DEFUN([SPL_AC_RWSEM_ACTIVITY], [
-	AC_MSG_CHECKING([whether struct rw_semaphore has member activity])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/rwsem.h>
-	],[
-		struct rw_semaphore dummy_semaphore __attribute__ ((unused));
-		dummy_semaphore.activity = 0;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_RWSEM_ACTIVITY, 1,
-		[struct rw_semaphore has member activity])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 4.8 API Change
-dnl #
-dnl # rwsem "->count" changed to atomic_long_t type
-dnl #
-AC_DEFUN([SPL_AC_RWSEM_ATOMIC_LONG_COUNT], [
-	AC_MSG_CHECKING(
-	[whether struct rw_semaphore has atomic_long_t member count])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/rwsem.h>
-	],[
-		DECLARE_RWSEM(dummy_semaphore);
-		(void) atomic_long_read(&dummy_semaphore.count);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_RWSEM_ATOMIC_LONG_COUNT, 1,
-		[struct rw_semaphore has atomic_long_t member count])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 3.9 API change,
-dnl # Moved things from linux/sched.h to linux/sched/rt.h
-dnl #
-AC_DEFUN([SPL_AC_SCHED_RT_HEADER],
-	[AC_MSG_CHECKING([whether header linux/sched/rt.h exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/sched.h>
-		#include <linux/sched/rt.h>
-	],[
-		return 0;
-	],[
-		AC_DEFINE(HAVE_SCHED_RT_HEADER, 1, [linux/sched/rt.h exists])
-		AC_MSG_RESULT(yes)
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 4.11 API change,
-dnl # Moved things from linux/sched.h to linux/sched/signal.h
-dnl #
-AC_DEFUN([SPL_AC_SCHED_SIGNAL_HEADER],
-	[AC_MSG_CHECKING([whether header linux/sched/signal.h exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/sched.h>
-		#include <linux/sched/signal.h>
-	],[
-		return 0;
-	],[
-		AC_DEFINE(HAVE_SCHED_SIGNAL_HEADER, 1, [linux/sched/signal.h exists])
-		AC_MSG_RESULT(yes)
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 4.11 API, a528d35e@torvalds/linux
-dnl # vfs_getattr(const struct path *p, struct kstat *s, u32 m, unsigned int f)
-dnl #
-AC_DEFUN([SPL_AC_4ARGS_VFS_GETATTR], [
-	AC_MSG_CHECKING([whether vfs_getattr() wants 4 args])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		vfs_getattr((const struct path *)NULL,
-			(struct kstat *)NULL,
-			(u32)0,
-			(unsigned int)0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_4ARGS_VFS_GETATTR, 1,
-		  [vfs_getattr wants 4 args])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 3.9 API 
-dnl # vfs_getattr(struct path *p, struct kstat *s)
-dnl #
-AC_DEFUN([SPL_AC_2ARGS_VFS_GETATTR], [
-	AC_MSG_CHECKING([whether vfs_getattr() wants 2 args])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		vfs_getattr((struct path *) NULL,
-			(struct kstat *)NULL);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_2ARGS_VFS_GETATTR, 1,
-			  [vfs_getattr wants 2 args])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # <3.9 API 
-dnl # vfs_getattr(struct vfsmount *v, struct dentry *d, struct kstat *k)
-dnl #
-AC_DEFUN([SPL_AC_3ARGS_VFS_GETATTR], [
-	AC_MSG_CHECKING([whether vfs_getattr() wants 3 args])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		vfs_getattr((struct vfsmount *)NULL,
-			(struct dentry *)NULL,
-			(struct kstat *)NULL);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_3ARGS_VFS_GETATTR, 1,
-		  [vfs_getattr wants 3 args])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 2.6.36 API compatibility.
-dnl # Added usleep_range timer.
-dnl # usleep_range is a finer precision implementation of msleep
-dnl # designed to be a drop-in replacement for udelay where a precise
-dnl # sleep / busy-wait is unnecessary.
-dnl #
-AC_DEFUN([SPL_AC_USLEEP_RANGE], [
-	AC_MSG_CHECKING([whether usleep_range() is available])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/delay.h>
-	],[
-		usleep_range(0, 0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_USLEEP_RANGE, 1,
-		          [usleep_range is available])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 2.6.35 API change,
-dnl # The cachep->gfpflags member was renamed cachep->allocflags.  These are
-dnl # private allocation flags which are applied when allocating a new slab
-dnl # in kmem_getpages().  Unfortunately there is no public API for setting
-dnl # non-default flags.
-dnl #
-AC_DEFUN([SPL_AC_KMEM_CACHE_ALLOCFLAGS], [
-	AC_MSG_CHECKING([whether struct kmem_cache has allocflags])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/slab.h>
-	],[
-		struct kmem_cache cachep __attribute__ ((unused));
-		cachep.allocflags = GFP_KERNEL;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KMEM_CACHE_ALLOCFLAGS, 1,
-			[struct kmem_cache has allocflags])
-	],[
-		AC_MSG_RESULT(no)
-
-		AC_MSG_CHECKING([whether struct kmem_cache has gfpflags])
-		SPL_LINUX_TRY_COMPILE([
-			#include <linux/slab.h>
-		],[
-			struct kmem_cache cachep __attribute__ ((unused));
-			cachep.gfpflags = GFP_KERNEL;
-		],[
-			AC_MSG_RESULT(yes)
-			AC_DEFINE(HAVE_KMEM_CACHE_GFPFLAGS, 1,
-				[struct kmem_cache has gfpflags])
-		],[
-			AC_MSG_RESULT(no)
-		])
-	])
-])
-
-dnl #
-dnl # 3.17 API change,
-dnl # wait_on_bit() no longer requires an action argument. The former
-dnl # "wait_on_bit" interface required an 'action' function to be provided
-dnl # which does the actual waiting. There were over 20 such functions in the
-dnl # kernel, many of them identical, though most cases can be satisfied by one
-dnl # of just two functions: one which uses io_schedule() and one which just
-dnl # uses schedule().  This API change was made to consolidate all of those
-dnl # redundant wait functions.
-dnl #
-AC_DEFUN([SPL_AC_WAIT_ON_BIT], [
-	AC_MSG_CHECKING([whether wait_on_bit() takes an action])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/wait.h>
-	],[
-		int (*action)(void *) = NULL;
-		wait_on_bit(NULL, 0, action, 0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_WAIT_ON_BIT_ACTION, 1, [yes])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 4.7 API change
-dnl # i_mutex is changed to i_rwsem. Instead of directly using
-dnl # i_mutex/i_rwsem, we should use inode_lock() and inode_lock_shared()
-dnl # We test inode_lock_shared because inode_lock is introduced earlier.
-dnl #
-AC_DEFUN([SPL_AC_INODE_LOCK], [
-	AC_MSG_CHECKING([whether inode_lock_shared() exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		struct inode *inode = NULL;
-		inode_lock_shared(inode);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_INODE_LOCK_SHARED, 1, [yes])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 4.9 API change
-dnl # group_info changed from 2d array via >blocks to 1d array via ->gid
-dnl #
-AC_DEFUN([SPL_AC_GROUP_INFO_GID], [
-	AC_MSG_CHECKING([whether group_info->gid exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/cred.h>
-	],[
-		struct group_info *gi = groups_alloc(1);
-		gi->gid[0] = KGIDT_INIT(0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_GROUP_INFO_GID, 1, [group_info->gid exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # grsecurity API change,
-dnl # kmem_cache_create() with SLAB_USERCOPY flag replaced by
-dnl # kmem_cache_create_usercopy().
-dnl #
-AC_DEFUN([SPL_AC_KMEM_CACHE_CREATE_USERCOPY], [
-	AC_MSG_CHECKING([whether kmem_cache_create_usercopy() exists])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/slab.h>
-		static void ctor(void *foo)
-		{
-			// fake ctor
-		}
-	],[
-		struct kmem_cache *skc_linux_cache;
-		const char *name = "test";
-		size_t size = 4096;
-		size_t align = 8;
-		unsigned long flags = 0;
-		size_t useroffset = 0;
-		size_t usersize = size - useroffset;
-
-		skc_linux_cache = kmem_cache_create_usercopy(
-			name, size, align, flags, useroffset, usersize, ctor);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KMEM_CACHE_CREATE_USERCOPY, 1,
-				[kmem_cache_create_usercopy() exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 4.13 API change
-dnl # Renamed struct wait_queue -> struct wait_queue_entry.
-dnl #
-AC_DEFUN([SPL_AC_WAIT_QUEUE_ENTRY_T], [
-	AC_MSG_CHECKING([whether wait_queue_entry_t exists])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/wait.h>
-	],[
-		wait_queue_entry_t *entry __attribute__ ((unused));
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_WAIT_QUEUE_ENTRY_T, 1,
-		    [wait_queue_entry_t exists])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 4.13 API change
-dnl # Renamed wait_queue_head::task_list -> wait_queue_head::head
-dnl # Renamed wait_queue_entry::task_list -> wait_queue_entry::entry
-dnl #
-AC_DEFUN([SPL_AC_WAIT_QUEUE_HEAD_ENTRY], [
-	AC_MSG_CHECKING([whether wq_head->head and wq_entry->entry exist])
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/wait.h>
-
-		#ifdef HAVE_WAIT_QUEUE_ENTRY_T
-		typedef wait_queue_head_t	spl_wait_queue_head_t;
-		typedef wait_queue_entry_t	spl_wait_queue_entry_t;
-		#else
-		typedef wait_queue_head_t	spl_wait_queue_head_t;
-		typedef wait_queue_t		spl_wait_queue_entry_t;
-		#endif
-	],[
-		spl_wait_queue_head_t wq_head;
-		spl_wait_queue_entry_t wq_entry;
-		struct list_head *head __attribute__ ((unused));
-		struct list_head *entry __attribute__ ((unused));
-
-		head = &wq_head.head;
-		entry = &wq_entry.entry;
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_WAIT_QUEUE_HEAD_ENTRY, 1,
-		    [wq_head->head and wq_entry->entry exist])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 3.19 API change
-dnl # The io_schedule_timeout() function is present in all 2.6.32 kernels
-dnl # but it was not exported until Linux 3.19.  The RHEL 7.x kernels which
-dnl # are based on a 3.10 kernel do export this symbol.
-dnl #
-AC_DEFUN([SPL_AC_IO_SCHEDULE_TIMEOUT], [
-	AC_MSG_CHECKING([whether io_schedule_timeout() is available])
-	SPL_LINUX_TRY_COMPILE_SYMBOL([
-		#include <linux/sched.h>
-	], [
-		(void) io_schedule_timeout(1);
-	], [io_schedule_timeout], [], [
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_IO_SCHEDULE_TIMEOUT, 1, [yes])
-	],[
-		AC_MSG_RESULT(no)
-	])
-])
-
-dnl #
-dnl # 4.14 API change
-dnl # kernel_write() which was introduced in 3.9 was updated to take
-dnl # the offset as a pointer which is needed by vn_rdwr().
-dnl #
-AC_DEFUN([SPL_AC_KERNEL_WRITE], [
-	AC_MSG_CHECKING([whether kernel_write() takes loff_t pointer])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		struct file *file = NULL;
-		const void *buf = NULL;
-		size_t count = 0;
-		loff_t *pos = NULL;
-		ssize_t ret;
-
-		ret = kernel_write(file, buf, count, pos);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KERNEL_WRITE_PPOS, 1,
-		    [kernel_write() take loff_t pointer])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 4.14 API change
-dnl # kernel_read() which has existed for forever was updated to take
-dnl # the offset as a pointer which is needed by vn_rdwr().
-dnl #
-AC_DEFUN([SPL_AC_KERNEL_READ], [
-	AC_MSG_CHECKING([whether kernel_read() takes loff_t pointer])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/fs.h>
-	],[
-		struct file *file = NULL;
-		void *buf = NULL;
-		size_t count = 0;
-		loff_t *pos = NULL;
-		ssize_t ret;
-
-		ret = kernel_read(file, buf, count, pos);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KERNEL_READ_PPOS, 1,
-		    [kernel_read() take loff_t pointer])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-
-dnl #
-dnl # 4.15 API change
-dnl # https://lkml.org/lkml/2017/11/25/90
-dnl # Check if timer_list.func get passed a timer_list or an unsigned long
-dnl # (older kernels).  Also sanity check the from_timer() and timer_setup()
-dnl # macros are available as well, since they will be used in the same newer
-dnl # kernels that support the new timer_list.func signature.
-dnl #
-AC_DEFUN([SPL_AC_KERNEL_TIMER_FUNCTION_TIMER_LIST], [
-	AC_MSG_CHECKING([whether timer_list.function gets a timer_list])
-	tmp_flags="$EXTRA_KCFLAGS"
-	EXTRA_KCFLAGS="-Werror"
-	SPL_LINUX_TRY_COMPILE([
-		#include <linux/timer.h>
-		void task_expire(struct timer_list *tl) {}
-	],[
-		#ifndef from_timer
-		#error "No from_timer() macro"
-		#endif
-
-		struct timer_list timer;
-		timer.function = task_expire;
-		timer_setup(&timer, NULL, 0);
-	],[
-		AC_MSG_RESULT(yes)
-		AC_DEFINE(HAVE_KERNEL_TIMER_FUNCTION_TIMER_LIST, 1,
-		    [timer_list.function gets a timer_list])
-	],[
-		AC_MSG_RESULT(no)
-	])
-	EXTRA_KCFLAGS="$tmp_flags"
-])
-- 
2.14.2

