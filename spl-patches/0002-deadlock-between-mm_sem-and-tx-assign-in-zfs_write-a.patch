From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: ilbsmart <wgqimut@gmail.com>
Date: Wed, 17 Oct 2018 02:11:24 +0800
Subject: [PATCH] deadlock between mm_sem and tx assign in zfs_write() and page
 fault

The bug time sequence:
1. thread #1, `zfs_write` assign a txg "n".
2. In a same process, thread #2, mmap page fault (which means the
   `mm_sem` is hold) occurred, `zfs_dirty_inode` open a txg failed,
   and wait previous txg "n" completed.
3. thread #1 call `uiomove` to write, however page fault is occurred
   in `uiomove`, which means it need `mm_sem`, but `mm_sem` is hold by
   thread #2, so it stuck and can't complete,  then txg "n" will
   not complete.

So thread #1 and thread #2 are deadlocked.

Reviewed-by: Chunwei Chen <tuxoko@gmail.com>
Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Reviewed-by: Matthew Ahrens <mahrens@delphix.com>
Signed-off-by: Grady Wong <grady.w@xtaotech.com>
Closes #7939

(backported from: zfs-upstream 779a6c0bf6df76e0dd92c1ccf81f48512b835bb0)
Signed-off-by: Stoiko Ivanov <s.ivanov@proxmox.com>
---
 include/sys/uio.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/include/sys/uio.h b/include/sys/uio.h
index 764beb9..2895690 100644
--- a/include/sys/uio.h
+++ b/include/sys/uio.h
@@ -53,6 +53,7 @@ typedef struct uio {
 	int		uio_iovcnt;
 	offset_t	uio_loffset;
 	uio_seg_t	uio_segflg;
+	boolean_t	uio_fault_disable;
 	uint16_t	uio_fmode;
 	uint16_t	uio_extflg;
 	offset_t	uio_limit;
